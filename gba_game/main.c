#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/background.h"
#include "images/logo.h"
#include "images/dream_land.h"
#include "images/marth.h"
#include "images/puff.h"


/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  START_WAIT,
  PLAY,
  ACTION,
  NEXT_STATE,
  WIN,
  LOSE,
  WAIT
};

//Removes a portion of the background image
void undraw(int row, int col, int width, int height, const u16 *image) {
  for (int i = 0; i < height; i++) {
      DMA[3].src = image + ((row + i)*WIDTH) + col;
      DMA[3].dst = videoBuffer + ((row + i)*WIDTH) + col;
      DMA[3].cnt = width | DMA_SOURCE_INCREMENT | DMA_DESTINATION_INCREMENT | DMA_ON;
    }
}

//Get manhattan distance
int manhattan_distance(struct character a, struct character b) {
  int rtn = 0;
  if(a.row >= b.row) {
    rtn += a.row-b.row;
  }
  else {
    rtn += b.row-a.row;
  }

  if(a.col >= b.col) {
    rtn += a.col-b.col;
  }
  else {
    rtn += b.col-a.col;
  }

  return rtn;
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3|BG2_ENABLE;

  // Text variables
  char* start_message;
  char* start_button;
  char* game_over;
  char* win;
  char* lose;
  char* score_message;
  char score[4];
  long cnt = 0;

  //character vairables (player is marth, computer is jigglypuff)
  struct character player = {.row = 100, .col = 20, .health = 1000, .attack = 20};
  struct character computer = {.row = 100, .col = 190, .health = 500, .attack = 150};

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    //waitForVBlank();
    switch (state) {
      case START:

        //Initialize player/computer stats
        player.row = 100;
        player.col = 20;
        player.health = 1000;
        player.attack = 20;
        computer.row = 100;
        computer.col = 190;
        computer.health = 500;
        computer.attack = 150;

        //Initialize start screen text
        start_message = "SSB MEMEE";
        start_button = "PRESS A TO BEGIN";

        //Draw background, logo, and text
        drawFullScreenImageDMA(background);
        drawImageDMA(20, 45, LOGO_WIDTH, LOGO_HEIGHT, logo);
        drawString(100,92,start_message,YELLOW);
        drawString(120,70,start_button,YELLOW);

        //Wait for user input
        state = START_WAIT;
        break;

      case START_WAIT:

        //Wait for user input
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          //On start, begin game play phase
          state = PLAY;
        }
        break;

      case PLAY:

        //Return to start state if select is pressed
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          break;
        }

        //Draw background
        drawFullScreenImageDMA(dream_land);

        //Draw characters
        drawImageDMA(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,marth);
        drawImageDMA(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,puff);

        //Move to action phase
        state = ACTION;
        break;

      case ACTION:
        waitForVBlank();

        //Incrment number of times action phase has been hit
        cnt++;

        //Return to start state if select is pressed
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          break;
        }

        if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && (player.col > computer.col || manhattan_distance(player, computer) > 75)) {
          if (player.col <= 194) {
            undraw(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,dream_land);
            player.col += 2;
            drawImageDMA(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,marth);
          }
          state = NEXT_STATE;
        }

        if (KEY_DOWN(BUTTON_LEFT, currentButtons) && (player.col < computer.col || manhattan_distance(player, computer) > 75)) {
          if (player.col >= 2) {
            undraw(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,dream_land);
            player.col -= 2;
            drawImageDMA(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,marth);
          }
          state = NEXT_STATE;
        }

        if (KEY_DOWN(BUTTON_UP, currentButtons) && (player.row < computer.row || manhattan_distance(player, computer) > 75)) {
          if (player.row >= 2) {
            undraw(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,dream_land);
            player.row -= 2;
            drawImageDMA(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,marth);
          }
          state = NEXT_STATE;
        }

        if (KEY_DOWN(BUTTON_DOWN, currentButtons) && (player.row > computer.row || manhattan_distance(player, computer) > 75)) {
          if (player.row <= 128) {
            undraw(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,dream_land);
            player.row += 2;
            drawImageDMA(player.row,player.col,MARTH_WIDTH,MARTH_HEIGHT,marth);
          }
          state = NEXT_STATE;
        }

        if(KEY_DOWN(BUTTON_A, currentButtons) && manhattan_distance(player,computer) < 80) {
          computer.health -= player.attack;
          state = NEXT_STATE;
        }

        //Computer moves once every 10 iterations
        if(cnt%10 != 1){break;}

        int computer_move = randint(0,50);
        if (computer_move < 10 && (computer.col > player.col || manhattan_distance(player, computer) > 90)) {
          if (computer.col <= 170) {
            undraw(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,dream_land);
            computer.col += 5;
            drawImageDMA(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,puff);
          }
          state = NEXT_STATE;
        }
        else if (computer_move < 20  && (computer.col < player.col || manhattan_distance(player, computer) > 90)) {
          if (computer.col >= 20) {
            undraw(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,dream_land);
            computer.col -= 5;
            drawImageDMA(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,puff);
          }
          state = NEXT_STATE;
        }
        else if (computer_move < 30 && (computer.row > player.row || manhattan_distance(player, computer) > 90)) {
          if (computer.row <= 100) {
            undraw(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,dream_land);
            computer.row += 5;
            drawImageDMA(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,puff);
          }
          state = NEXT_STATE;
        }
        else if (computer_move < 40 && (computer.row < player.row || manhattan_distance(player, computer) > 90)) {
          if (computer.row >= 20) {
            undraw(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,dream_land);
            computer.row -= 5;
            drawImageDMA(computer.row,computer.col,PUFF_WIDTH,PUFF_HEIGHT,puff);
          }
          state = NEXT_STATE;
        }
        else {
          if(manhattan_distance(player,computer) < 80) {
            player.health -= computer.attack;
            state = NEXT_STATE;
          }
        }

        break;

      case NEXT_STATE:

        //Determines whether we should keep playing or go to win/lose screen
        if (player.health <= 0) {
          state = LOSE;
        }
        else if (computer.health <= 0) {
          state = WIN;
        }
        else {
          state = ACTION;
        }
        break;
      case WIN:

        //Return to start state if select is pressed
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
            state = START;
            break;
        }

        //Display game over win message
        game_over = "GAME OVER";
        win = "YOU WIN!";
        score_message = "SCORE: ";
        fillScreenDMA(BLACK);
        drawString(60,92,game_over,YELLOW);
        drawString(80,96,win,GREEN);
        sprintf(score, "%d", player.health-computer.health);
        drawString(100, 94, score_message, WHITE);
        drawString(100, 132, score, WHITE);
        state = WAIT;
        break;

      case LOSE:

        //Return to start state if select is pressed
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
            state = START;
            break;
        }

        //Display game over loss message
        game_over = "GAME OVER";
        lose = "YOU LOSE:(";
        score_message = "SCORE: ";
        fillScreenDMA(BLACK);
        drawString(60,92,game_over,YELLOW);
        drawString(80,90,lose,RED);
        sprintf(score, "%d", player.health-computer.health);
        drawString(100, 92, score_message, WHITE);
        drawString(100, 130, score, WHITE);
        state = WAIT;
        break;

      case WAIT:
        //Wait for user input
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          //On start, begin game play phase
          state = START;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
